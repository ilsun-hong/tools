#!/bin/bash

# gwd - Git Worktree 삭제 스크립트
# 사용법:
#   gwd <branch-name>     - 특정 worktree 삭제
#   gwd -a, --all         - merge된 모든 worktree 삭제
#   gwd -a -f, --all --force - 모든 worktree 삭제 (merge 여부 무관)

set -e

# 색상 정의
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# 에러 출력 함수
error() {
    echo -e "${RED}오류: $1${NC}" >&2
    exit 1
}

# 정보 출력 함수
info() {
    echo -e "${GREEN}$1${NC}"
}

# 경고 출력 함수
warn() {
    echo -e "${YELLOW}$1${NC}"
}

# 사용법 출력
usage() {
    echo ""
    echo -e "${CYAN}gwd - Git Worktree 삭제 스크립트${NC}"
    echo ""
    echo "사용법:"
    echo "  gwd <branch-name>        특정 worktree와 브랜치 삭제"
    echo "  gwd -a, --all            merge된 모든 worktree 삭제"
    echo "  gwd -a -f, --all --force 모든 worktree 삭제 (merge 여부 무관)"
    echo "  gwd -h, --help           도움말 표시"
    echo ""
}

# 옵션 파싱
ALL_MODE=false
FORCE_MODE=false
BRANCH_NAME=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -a|--all)
            ALL_MODE=true
            shift
            ;;
        -f|--force)
            FORCE_MODE=true
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        -*)
            error "알 수 없는 옵션: $1\n사용법: gwd --help"
            ;;
        *)
            BRANCH_NAME="$1"
            shift
            ;;
    esac
done

# git 디렉토리 확인
if ! git rev-parse --is-inside-work-tree &>/dev/null; then
    error "현재 디렉토리는 git 저장소가 아닙니다."
fi

# git root 디렉토리 찾기
GIT_ROOT=$(git rev-parse --show-toplevel)
PROJECT_NAME=$(basename "$GIT_ROOT")
PARENT_DIR=$(dirname "$GIT_ROOT")

# 브랜치가 merge되었는지 확인하는 함수
is_branch_merged() {
    local branch="$1"

    # origin/main 또는 origin/master 확인
    local remote_main=""
    if git show-ref --verify --quiet refs/remotes/origin/main; then
        remote_main="origin/main"
    elif git show-ref --verify --quiet refs/remotes/origin/master; then
        remote_main="origin/master"
    else
        # origin/main,master가 없으면 로컬 기준으로 fallback
        if git show-ref --verify --quiet refs/heads/main; then
            remote_main="main"
        elif git show-ref --verify --quiet refs/heads/master; then
            remote_main="master"
        else
            remote_main=$(git rev-parse --abbrev-ref HEAD)
        fi
    fi

    # 방법 1: origin/main에 머지되었는지 확인 (일반 merge)
    if git branch --merged "$remote_main" 2>/dev/null | grep -qE "^[[:space:]]*${branch}$"; then
        return 0
    fi

    # 방법 2: 리모트 브랜치가 삭제되었으면 머지된 것으로 간주 (PR 머지 후 삭제됨)
    if ! git show-ref --verify --quiet "refs/remotes/origin/${branch}"; then
        return 0
    fi

    # 방법 3: 브랜치의 HEAD가 origin/main의 ancestor인지 확인 (squash/rebase merge 감지)
    local branch_head
    branch_head=$(git rev-parse "$branch" 2>/dev/null) || return 1
    if git merge-base --is-ancestor "$branch_head" "$remote_main" 2>/dev/null; then
        return 0
    fi

    return 1
}

# 현재 디렉토리가 해당 worktree 내에 있는지 확인
is_current_directory() {
    local wt_path="$1"
    [[ "$PWD" == "$wt_path"* ]]
}

# worktree에 uncommitted 변경사항 또는 untracked 파일이 있는지 확인
has_dirty_files() {
    local wt_path="$1"
    # git status --porcelain은 staged, unstaged, untracked 파일 모두 표시
    [ -n "$(git -C "$wt_path" status --porcelain 2>/dev/null)" ]
}

# 단일 worktree 삭제 함수
delete_single_worktree() {
    local branch="$1"
    local force="$2"
    local worktree_dir="${PARENT_DIR}/${PROJECT_NAME}_${branch}"

    # worktree 존재 확인
    if [ ! -d "$worktree_dir" ]; then
        warn "Worktree 디렉토리가 존재하지 않습니다: $worktree_dir"
        return 1
    fi

    # worktree 삭제
    info "  Worktree 삭제 중: $worktree_dir"
    if [ "$force" = true ]; then
        git worktree remove "$worktree_dir" --force
    else
        git worktree remove "$worktree_dir"
    fi

    # 브랜치 삭제
    if [ "$force" = true ]; then
        if git branch -D "$branch" 2>/dev/null; then
            info "  브랜치 '$branch' 강제 삭제 완료"
        else
            warn "  브랜치 '$branch' 삭제 실패"
        fi
    else
        if git branch -d "$branch" 2>/dev/null; then
            info "  브랜치 '$branch' 삭제 완료"
        elif git branch -D "$branch" 2>/dev/null; then
            warn "  브랜치 '$branch' 강제 삭제 (머지되지 않은 변경사항 있음)"
        else
            warn "  브랜치 '$branch' 삭제 실패"
        fi
    fi

    return 0
}

# ALL 모드: 모든 worktree 삭제
if [ "$ALL_MODE" = true ]; then
    echo ""
    echo -e "${CYAN}=== 모든 Worktree 삭제 모드 ===${NC}"

    if [ "$FORCE_MODE" = true ]; then
        echo -e "${RED}⚠️  강제 모드: merge 여부와 관계없이 모든 worktree를 삭제합니다${NC}"
    else
        echo -e "${YELLOW}일반 모드: merge된 worktree만 삭제합니다${NC}"
        echo -e "${CYAN}리모트 상태 동기화 중...${NC}"
        git fetch origin --prune 2>/dev/null || true
    fi
    echo ""

    # worktree 목록 가져오기 (main worktree 제외)
    WORKTREES=()
    BRANCHES=()

    while IFS= read -r line; do
        wt_path=$(echo "$line" | awk '{print $1}')
        wt_branch=$(echo "$line" | awk '{print $3}' | tr -d '[]')

        # main worktree (GIT_ROOT)는 제외
        if [ "$wt_path" = "$GIT_ROOT" ]; then
            continue
        fi

        # main, master 브랜치는 제외
        if [ "$wt_branch" = "main" ] || [ "$wt_branch" = "master" ]; then
            continue
        fi

        # detached HEAD는 제외
        if [ -z "$wt_branch" ] || [ "$wt_branch" = "detached" ]; then
            continue
        fi

        # 현재 작업 디렉토리인 경우 스킵 (--force여도 스킵)
        if is_current_directory "$wt_path"; then
            warn "스킵: '$wt_branch' (현재 작업 중인 디렉토리)"
            continue
        fi

        # force 모드가 아니면 추가 체크
        if [ "$FORCE_MODE" = false ]; then
            # dirty 파일 체크 (uncommitted 또는 untracked)
            if has_dirty_files "$wt_path"; then
                warn "스킵: '$wt_branch' (uncommitted 또는 untracked 파일 있음)"
                continue
            fi

            # merge 여부 확인
            if ! is_branch_merged "$wt_branch"; then
                warn "스킵: '$wt_branch' (merge되지 않음)"
                continue
            fi
        fi

        WORKTREES+=("$wt_path")
        BRANCHES+=("$wt_branch")
    done < <(git worktree list)

    # 삭제할 worktree가 없으면 종료
    if [ ${#WORKTREES[@]} -eq 0 ]; then
        echo ""
        if [ "$FORCE_MODE" = true ]; then
            info "삭제할 worktree가 없습니다."
        else
            info "삭제할 merge된 worktree가 없습니다."
            echo -e "${CYAN}팁: -f 옵션으로 모든 worktree를 삭제할 수 있습니다.${NC}"
        fi
        echo ""
        exit 0
    fi

    # 삭제 대상 출력
    echo -e "${CYAN}삭제 대상 (${#WORKTREES[@]}개):${NC}"
    for i in "${!WORKTREES[@]}"; do
        echo "  - ${BRANCHES[$i]} (${WORKTREES[$i]})"
    done
    echo ""

    # 확인
    read -p "정말 삭제하시겠습니까? (y/n): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        warn "취소되었습니다."
        exit 0
    fi

    echo ""
    # 삭제 실행
    deleted_count=0
    for i in "${!BRANCHES[@]}"; do
        echo -e "${CYAN}[$((i+1))/${#BRANCHES[@]}] ${BRANCHES[$i]} 삭제 중...${NC}"
        if delete_single_worktree "${BRANCHES[$i]}" "$FORCE_MODE"; then
            ((deleted_count++))
        fi
        echo ""
    done

    info "완료! ${deleted_count}개의 worktree가 삭제되었습니다."
    exit 0
fi

# 단일 브랜치 모드
if [ -z "$BRANCH_NAME" ]; then
    echo ""
    echo -e "${CYAN}현재 등록된 worktree 목록:${NC}"
    echo ""
    git worktree list
    echo ""
    usage
    error "브랜치명을 입력해주세요."
fi

# worktree 디렉토리 경로
WORKTREE_DIR="${PARENT_DIR}/${PROJECT_NAME}_${BRANCH_NAME}"

# worktree 존재 확인
if [ ! -d "$WORKTREE_DIR" ]; then
    error "Worktree 디렉토리가 존재하지 않습니다: $WORKTREE_DIR"
fi

# 삭제 대상 정보 출력
echo ""
echo -e "${CYAN}삭제 대상:${NC}"
echo "  Worktree: $WORKTREE_DIR"
echo "  브랜치: $BRANCH_NAME"
echo ""

# 확인
read -p "정말 삭제하시겠습니까? (y/n): " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    warn "취소되었습니다."
    exit 0
fi

# worktree 삭제
info "Worktree 삭제 중..."
git worktree remove "$WORKTREE_DIR" --force
info "Worktree 삭제 완료!"

# 브랜치 삭제
info "브랜치 삭제 중..."
if git branch -d "$BRANCH_NAME" 2>/dev/null; then
    info "브랜치 '$BRANCH_NAME' 삭제 완료"
elif git branch -D "$BRANCH_NAME" 2>/dev/null; then
    warn "브랜치 '$BRANCH_NAME' 강제 삭제 완료 (머지되지 않은 변경사항 있음)"
else
    warn "브랜치 '$BRANCH_NAME' 삭제 실패 (이미 삭제되었거나 다른 문제)"
fi

echo ""
info "완료!"
